// Code generated by counterfeiter. DO NOT EDIT.
package sessionfakes

import (
	"context"
	"sync"

	"github.com/heat1q/boardsite/api/types"
	"github.com/heat1q/boardsite/attachment"
	"github.com/heat1q/boardsite/session"
)

type FakeController struct {
	AddPagesStub        func(context.Context, []string, []int, map[string]*session.PageMeta) error
	addPagesMutex       sync.RWMutex
	addPagesArgsForCall []struct {
		arg1 context.Context
		arg2 []string
		arg3 []int
		arg4 map[string]*session.PageMeta
	}
	addPagesReturns struct {
		result1 error
	}
	addPagesReturnsOnCall map[int]struct {
		result1 error
	}
	AttachmentsStub        func() attachment.Handler
	attachmentsMutex       sync.RWMutex
	attachmentsArgsForCall []struct {
	}
	attachmentsReturns struct {
		result1 attachment.Handler
	}
	attachmentsReturnsOnCall map[int]struct {
		result1 attachment.Handler
	}
	CloseStub        func()
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	DeletePagesStub        func(context.Context, ...string) error
	deletePagesMutex       sync.RWMutex
	deletePagesArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	deletePagesReturns struct {
		result1 error
	}
	deletePagesReturnsOnCall map[int]struct {
		result1 error
	}
	GetPagesStub        func(context.Context) ([]string, map[string]*session.PageMeta, error)
	getPagesMutex       sync.RWMutex
	getPagesArgsForCall []struct {
		arg1 context.Context
	}
	getPagesReturns struct {
		result1 []string
		result2 map[string]*session.PageMeta
		result3 error
	}
	getPagesReturnsOnCall map[int]struct {
		result1 []string
		result2 map[string]*session.PageMeta
		result3 error
	}
	GetPagesSetStub        func(context.Context) map[string]struct{}
	getPagesSetMutex       sync.RWMutex
	getPagesSetArgsForCall []struct {
		arg1 context.Context
	}
	getPagesSetReturns struct {
		result1 map[string]struct{}
	}
	getPagesSetReturnsOnCall map[int]struct {
		result1 map[string]struct{}
	}
	GetStrokesStub        func(context.Context, string) ([]*session.Stroke, error)
	getStrokesMutex       sync.RWMutex
	getStrokesArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getStrokesReturns struct {
		result1 []*session.Stroke
		result2 error
	}
	getStrokesReturnsOnCall map[int]struct {
		result1 []*session.Stroke
		result2 error
	}
	GetUserReadyStub        func(string) (*session.User, error)
	getUserReadyMutex       sync.RWMutex
	getUserReadyArgsForCall []struct {
		arg1 string
	}
	getUserReadyReturns struct {
		result1 *session.User
		result2 error
	}
	getUserReadyReturnsOnCall map[int]struct {
		result1 *session.User
		result2 error
	}
	GetUsersStub        func() map[string]*session.User
	getUsersMutex       sync.RWMutex
	getUsersArgsForCall []struct {
	}
	getUsersReturns struct {
		result1 map[string]*session.User
	}
	getUsersReturnsOnCall map[int]struct {
		result1 map[string]*session.User
	}
	IDStub        func() string
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 string
	}
	iDReturnsOnCall map[int]struct {
		result1 string
	}
	IsUserConnectedStub        func(string) bool
	isUserConnectedMutex       sync.RWMutex
	isUserConnectedArgsForCall []struct {
		arg1 string
	}
	isUserConnectedReturns struct {
		result1 bool
	}
	isUserConnectedReturnsOnCall map[int]struct {
		result1 bool
	}
	IsUserReadyStub        func(string) bool
	isUserReadyMutex       sync.RWMutex
	isUserReadyArgsForCall []struct {
		arg1 string
	}
	isUserReadyReturns struct {
		result1 bool
	}
	isUserReadyReturnsOnCall map[int]struct {
		result1 bool
	}
	IsValidPageStub        func(context.Context, ...string) bool
	isValidPageMutex       sync.RWMutex
	isValidPageArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	isValidPageReturns struct {
		result1 bool
	}
	isValidPageReturnsOnCall map[int]struct {
		result1 bool
	}
	NewUserStub        func(string, string) (*session.User, error)
	newUserMutex       sync.RWMutex
	newUserArgsForCall []struct {
		arg1 string
		arg2 string
	}
	newUserReturns struct {
		result1 *session.User
		result2 error
	}
	newUserReturnsOnCall map[int]struct {
		result1 *session.User
		result2 error
	}
	NumUsersStub        func() int
	numUsersMutex       sync.RWMutex
	numUsersArgsForCall []struct {
	}
	numUsersReturns struct {
		result1 int
	}
	numUsersReturnsOnCall map[int]struct {
		result1 int
	}
	ReceiveStub        func(context.Context, *types.Message) error
	receiveMutex       sync.RWMutex
	receiveArgsForCall []struct {
		arg1 context.Context
		arg2 *types.Message
	}
	receiveReturns struct {
		result1 error
	}
	receiveReturnsOnCall map[int]struct {
		result1 error
	}
	SyncPagesStub        func(context.Context) error
	syncPagesMutex       sync.RWMutex
	syncPagesArgsForCall []struct {
		arg1 context.Context
	}
	syncPagesReturns struct {
		result1 error
	}
	syncPagesReturnsOnCall map[int]struct {
		result1 error
	}
	UpdatePagesStub        func(context.Context, []string, map[string]*session.PageMeta, bool) error
	updatePagesMutex       sync.RWMutex
	updatePagesArgsForCall []struct {
		arg1 context.Context
		arg2 []string
		arg3 map[string]*session.PageMeta
		arg4 bool
	}
	updatePagesReturns struct {
		result1 error
	}
	updatePagesReturnsOnCall map[int]struct {
		result1 error
	}
	UserConnectStub        func(*session.User)
	userConnectMutex       sync.RWMutex
	userConnectArgsForCall []struct {
		arg1 *session.User
	}
	UserDisconnectStub        func(context.Context, string)
	userDisconnectMutex       sync.RWMutex
	userDisconnectArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	UserReadyStub        func(*session.User) error
	userReadyMutex       sync.RWMutex
	userReadyArgsForCall []struct {
		arg1 *session.User
	}
	userReadyReturns struct {
		result1 error
	}
	userReadyReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeController) AddPages(arg1 context.Context, arg2 []string, arg3 []int, arg4 map[string]*session.PageMeta) error {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	var arg3Copy []int
	if arg3 != nil {
		arg3Copy = make([]int, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.addPagesMutex.Lock()
	ret, specificReturn := fake.addPagesReturnsOnCall[len(fake.addPagesArgsForCall)]
	fake.addPagesArgsForCall = append(fake.addPagesArgsForCall, struct {
		arg1 context.Context
		arg2 []string
		arg3 []int
		arg4 map[string]*session.PageMeta
	}{arg1, arg2Copy, arg3Copy, arg4})
	stub := fake.AddPagesStub
	fakeReturns := fake.addPagesReturns
	fake.recordInvocation("AddPages", []interface{}{arg1, arg2Copy, arg3Copy, arg4})
	fake.addPagesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) AddPagesCallCount() int {
	fake.addPagesMutex.RLock()
	defer fake.addPagesMutex.RUnlock()
	return len(fake.addPagesArgsForCall)
}

func (fake *FakeController) AddPagesCalls(stub func(context.Context, []string, []int, map[string]*session.PageMeta) error) {
	fake.addPagesMutex.Lock()
	defer fake.addPagesMutex.Unlock()
	fake.AddPagesStub = stub
}

func (fake *FakeController) AddPagesArgsForCall(i int) (context.Context, []string, []int, map[string]*session.PageMeta) {
	fake.addPagesMutex.RLock()
	defer fake.addPagesMutex.RUnlock()
	argsForCall := fake.addPagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeController) AddPagesReturns(result1 error) {
	fake.addPagesMutex.Lock()
	defer fake.addPagesMutex.Unlock()
	fake.AddPagesStub = nil
	fake.addPagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) AddPagesReturnsOnCall(i int, result1 error) {
	fake.addPagesMutex.Lock()
	defer fake.addPagesMutex.Unlock()
	fake.AddPagesStub = nil
	if fake.addPagesReturnsOnCall == nil {
		fake.addPagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addPagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) Attachments() attachment.Handler {
	fake.attachmentsMutex.Lock()
	ret, specificReturn := fake.attachmentsReturnsOnCall[len(fake.attachmentsArgsForCall)]
	fake.attachmentsArgsForCall = append(fake.attachmentsArgsForCall, struct {
	}{})
	stub := fake.AttachmentsStub
	fakeReturns := fake.attachmentsReturns
	fake.recordInvocation("Attachments", []interface{}{})
	fake.attachmentsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) AttachmentsCallCount() int {
	fake.attachmentsMutex.RLock()
	defer fake.attachmentsMutex.RUnlock()
	return len(fake.attachmentsArgsForCall)
}

func (fake *FakeController) AttachmentsCalls(stub func() attachment.Handler) {
	fake.attachmentsMutex.Lock()
	defer fake.attachmentsMutex.Unlock()
	fake.AttachmentsStub = stub
}

func (fake *FakeController) AttachmentsReturns(result1 attachment.Handler) {
	fake.attachmentsMutex.Lock()
	defer fake.attachmentsMutex.Unlock()
	fake.AttachmentsStub = nil
	fake.attachmentsReturns = struct {
		result1 attachment.Handler
	}{result1}
}

func (fake *FakeController) AttachmentsReturnsOnCall(i int, result1 attachment.Handler) {
	fake.attachmentsMutex.Lock()
	defer fake.attachmentsMutex.Unlock()
	fake.AttachmentsStub = nil
	if fake.attachmentsReturnsOnCall == nil {
		fake.attachmentsReturnsOnCall = make(map[int]struct {
			result1 attachment.Handler
		})
	}
	fake.attachmentsReturnsOnCall[i] = struct {
		result1 attachment.Handler
	}{result1}
}

func (fake *FakeController) Close() {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		fake.CloseStub()
	}
}

func (fake *FakeController) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeController) CloseCalls(stub func()) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeController) DeletePages(arg1 context.Context, arg2 ...string) error {
	fake.deletePagesMutex.Lock()
	ret, specificReturn := fake.deletePagesReturnsOnCall[len(fake.deletePagesArgsForCall)]
	fake.deletePagesArgsForCall = append(fake.deletePagesArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2})
	stub := fake.DeletePagesStub
	fakeReturns := fake.deletePagesReturns
	fake.recordInvocation("DeletePages", []interface{}{arg1, arg2})
	fake.deletePagesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) DeletePagesCallCount() int {
	fake.deletePagesMutex.RLock()
	defer fake.deletePagesMutex.RUnlock()
	return len(fake.deletePagesArgsForCall)
}

func (fake *FakeController) DeletePagesCalls(stub func(context.Context, ...string) error) {
	fake.deletePagesMutex.Lock()
	defer fake.deletePagesMutex.Unlock()
	fake.DeletePagesStub = stub
}

func (fake *FakeController) DeletePagesArgsForCall(i int) (context.Context, []string) {
	fake.deletePagesMutex.RLock()
	defer fake.deletePagesMutex.RUnlock()
	argsForCall := fake.deletePagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeController) DeletePagesReturns(result1 error) {
	fake.deletePagesMutex.Lock()
	defer fake.deletePagesMutex.Unlock()
	fake.DeletePagesStub = nil
	fake.deletePagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) DeletePagesReturnsOnCall(i int, result1 error) {
	fake.deletePagesMutex.Lock()
	defer fake.deletePagesMutex.Unlock()
	fake.DeletePagesStub = nil
	if fake.deletePagesReturnsOnCall == nil {
		fake.deletePagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deletePagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) GetPages(arg1 context.Context) ([]string, map[string]*session.PageMeta, error) {
	fake.getPagesMutex.Lock()
	ret, specificReturn := fake.getPagesReturnsOnCall[len(fake.getPagesArgsForCall)]
	fake.getPagesArgsForCall = append(fake.getPagesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetPagesStub
	fakeReturns := fake.getPagesReturns
	fake.recordInvocation("GetPages", []interface{}{arg1})
	fake.getPagesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeController) GetPagesCallCount() int {
	fake.getPagesMutex.RLock()
	defer fake.getPagesMutex.RUnlock()
	return len(fake.getPagesArgsForCall)
}

func (fake *FakeController) GetPagesCalls(stub func(context.Context) ([]string, map[string]*session.PageMeta, error)) {
	fake.getPagesMutex.Lock()
	defer fake.getPagesMutex.Unlock()
	fake.GetPagesStub = stub
}

func (fake *FakeController) GetPagesArgsForCall(i int) context.Context {
	fake.getPagesMutex.RLock()
	defer fake.getPagesMutex.RUnlock()
	argsForCall := fake.getPagesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) GetPagesReturns(result1 []string, result2 map[string]*session.PageMeta, result3 error) {
	fake.getPagesMutex.Lock()
	defer fake.getPagesMutex.Unlock()
	fake.GetPagesStub = nil
	fake.getPagesReturns = struct {
		result1 []string
		result2 map[string]*session.PageMeta
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeController) GetPagesReturnsOnCall(i int, result1 []string, result2 map[string]*session.PageMeta, result3 error) {
	fake.getPagesMutex.Lock()
	defer fake.getPagesMutex.Unlock()
	fake.GetPagesStub = nil
	if fake.getPagesReturnsOnCall == nil {
		fake.getPagesReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 map[string]*session.PageMeta
			result3 error
		})
	}
	fake.getPagesReturnsOnCall[i] = struct {
		result1 []string
		result2 map[string]*session.PageMeta
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeController) GetPagesSet(arg1 context.Context) map[string]struct{} {
	fake.getPagesSetMutex.Lock()
	ret, specificReturn := fake.getPagesSetReturnsOnCall[len(fake.getPagesSetArgsForCall)]
	fake.getPagesSetArgsForCall = append(fake.getPagesSetArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetPagesSetStub
	fakeReturns := fake.getPagesSetReturns
	fake.recordInvocation("GetPagesSet", []interface{}{arg1})
	fake.getPagesSetMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) GetPagesSetCallCount() int {
	fake.getPagesSetMutex.RLock()
	defer fake.getPagesSetMutex.RUnlock()
	return len(fake.getPagesSetArgsForCall)
}

func (fake *FakeController) GetPagesSetCalls(stub func(context.Context) map[string]struct{}) {
	fake.getPagesSetMutex.Lock()
	defer fake.getPagesSetMutex.Unlock()
	fake.GetPagesSetStub = stub
}

func (fake *FakeController) GetPagesSetArgsForCall(i int) context.Context {
	fake.getPagesSetMutex.RLock()
	defer fake.getPagesSetMutex.RUnlock()
	argsForCall := fake.getPagesSetArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) GetPagesSetReturns(result1 map[string]struct{}) {
	fake.getPagesSetMutex.Lock()
	defer fake.getPagesSetMutex.Unlock()
	fake.GetPagesSetStub = nil
	fake.getPagesSetReturns = struct {
		result1 map[string]struct{}
	}{result1}
}

func (fake *FakeController) GetPagesSetReturnsOnCall(i int, result1 map[string]struct{}) {
	fake.getPagesSetMutex.Lock()
	defer fake.getPagesSetMutex.Unlock()
	fake.GetPagesSetStub = nil
	if fake.getPagesSetReturnsOnCall == nil {
		fake.getPagesSetReturnsOnCall = make(map[int]struct {
			result1 map[string]struct{}
		})
	}
	fake.getPagesSetReturnsOnCall[i] = struct {
		result1 map[string]struct{}
	}{result1}
}

func (fake *FakeController) GetStrokes(arg1 context.Context, arg2 string) ([]*session.Stroke, error) {
	fake.getStrokesMutex.Lock()
	ret, specificReturn := fake.getStrokesReturnsOnCall[len(fake.getStrokesArgsForCall)]
	fake.getStrokesArgsForCall = append(fake.getStrokesArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetStrokesStub
	fakeReturns := fake.getStrokesReturns
	fake.recordInvocation("GetStrokes", []interface{}{arg1, arg2})
	fake.getStrokesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeController) GetStrokesCallCount() int {
	fake.getStrokesMutex.RLock()
	defer fake.getStrokesMutex.RUnlock()
	return len(fake.getStrokesArgsForCall)
}

func (fake *FakeController) GetStrokesCalls(stub func(context.Context, string) ([]*session.Stroke, error)) {
	fake.getStrokesMutex.Lock()
	defer fake.getStrokesMutex.Unlock()
	fake.GetStrokesStub = stub
}

func (fake *FakeController) GetStrokesArgsForCall(i int) (context.Context, string) {
	fake.getStrokesMutex.RLock()
	defer fake.getStrokesMutex.RUnlock()
	argsForCall := fake.getStrokesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeController) GetStrokesReturns(result1 []*session.Stroke, result2 error) {
	fake.getStrokesMutex.Lock()
	defer fake.getStrokesMutex.Unlock()
	fake.GetStrokesStub = nil
	fake.getStrokesReturns = struct {
		result1 []*session.Stroke
		result2 error
	}{result1, result2}
}

func (fake *FakeController) GetStrokesReturnsOnCall(i int, result1 []*session.Stroke, result2 error) {
	fake.getStrokesMutex.Lock()
	defer fake.getStrokesMutex.Unlock()
	fake.GetStrokesStub = nil
	if fake.getStrokesReturnsOnCall == nil {
		fake.getStrokesReturnsOnCall = make(map[int]struct {
			result1 []*session.Stroke
			result2 error
		})
	}
	fake.getStrokesReturnsOnCall[i] = struct {
		result1 []*session.Stroke
		result2 error
	}{result1, result2}
}

func (fake *FakeController) GetUserReady(arg1 string) (*session.User, error) {
	fake.getUserReadyMutex.Lock()
	ret, specificReturn := fake.getUserReadyReturnsOnCall[len(fake.getUserReadyArgsForCall)]
	fake.getUserReadyArgsForCall = append(fake.getUserReadyArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetUserReadyStub
	fakeReturns := fake.getUserReadyReturns
	fake.recordInvocation("GetUserReady", []interface{}{arg1})
	fake.getUserReadyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeController) GetUserReadyCallCount() int {
	fake.getUserReadyMutex.RLock()
	defer fake.getUserReadyMutex.RUnlock()
	return len(fake.getUserReadyArgsForCall)
}

func (fake *FakeController) GetUserReadyCalls(stub func(string) (*session.User, error)) {
	fake.getUserReadyMutex.Lock()
	defer fake.getUserReadyMutex.Unlock()
	fake.GetUserReadyStub = stub
}

func (fake *FakeController) GetUserReadyArgsForCall(i int) string {
	fake.getUserReadyMutex.RLock()
	defer fake.getUserReadyMutex.RUnlock()
	argsForCall := fake.getUserReadyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) GetUserReadyReturns(result1 *session.User, result2 error) {
	fake.getUserReadyMutex.Lock()
	defer fake.getUserReadyMutex.Unlock()
	fake.GetUserReadyStub = nil
	fake.getUserReadyReturns = struct {
		result1 *session.User
		result2 error
	}{result1, result2}
}

func (fake *FakeController) GetUserReadyReturnsOnCall(i int, result1 *session.User, result2 error) {
	fake.getUserReadyMutex.Lock()
	defer fake.getUserReadyMutex.Unlock()
	fake.GetUserReadyStub = nil
	if fake.getUserReadyReturnsOnCall == nil {
		fake.getUserReadyReturnsOnCall = make(map[int]struct {
			result1 *session.User
			result2 error
		})
	}
	fake.getUserReadyReturnsOnCall[i] = struct {
		result1 *session.User
		result2 error
	}{result1, result2}
}

func (fake *FakeController) GetUsers() map[string]*session.User {
	fake.getUsersMutex.Lock()
	ret, specificReturn := fake.getUsersReturnsOnCall[len(fake.getUsersArgsForCall)]
	fake.getUsersArgsForCall = append(fake.getUsersArgsForCall, struct {
	}{})
	stub := fake.GetUsersStub
	fakeReturns := fake.getUsersReturns
	fake.recordInvocation("GetUsers", []interface{}{})
	fake.getUsersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) GetUsersCallCount() int {
	fake.getUsersMutex.RLock()
	defer fake.getUsersMutex.RUnlock()
	return len(fake.getUsersArgsForCall)
}

func (fake *FakeController) GetUsersCalls(stub func() map[string]*session.User) {
	fake.getUsersMutex.Lock()
	defer fake.getUsersMutex.Unlock()
	fake.GetUsersStub = stub
}

func (fake *FakeController) GetUsersReturns(result1 map[string]*session.User) {
	fake.getUsersMutex.Lock()
	defer fake.getUsersMutex.Unlock()
	fake.GetUsersStub = nil
	fake.getUsersReturns = struct {
		result1 map[string]*session.User
	}{result1}
}

func (fake *FakeController) GetUsersReturnsOnCall(i int, result1 map[string]*session.User) {
	fake.getUsersMutex.Lock()
	defer fake.getUsersMutex.Unlock()
	fake.GetUsersStub = nil
	if fake.getUsersReturnsOnCall == nil {
		fake.getUsersReturnsOnCall = make(map[int]struct {
			result1 map[string]*session.User
		})
	}
	fake.getUsersReturnsOnCall[i] = struct {
		result1 map[string]*session.User
	}{result1}
}

func (fake *FakeController) ID() string {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	stub := fake.IDStub
	fakeReturns := fake.iDReturns
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeController) IDCalls(stub func() string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakeController) IDReturns(result1 string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeController) IDReturnsOnCall(i int, result1 string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeController) IsUserConnected(arg1 string) bool {
	fake.isUserConnectedMutex.Lock()
	ret, specificReturn := fake.isUserConnectedReturnsOnCall[len(fake.isUserConnectedArgsForCall)]
	fake.isUserConnectedArgsForCall = append(fake.isUserConnectedArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.IsUserConnectedStub
	fakeReturns := fake.isUserConnectedReturns
	fake.recordInvocation("IsUserConnected", []interface{}{arg1})
	fake.isUserConnectedMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) IsUserConnectedCallCount() int {
	fake.isUserConnectedMutex.RLock()
	defer fake.isUserConnectedMutex.RUnlock()
	return len(fake.isUserConnectedArgsForCall)
}

func (fake *FakeController) IsUserConnectedCalls(stub func(string) bool) {
	fake.isUserConnectedMutex.Lock()
	defer fake.isUserConnectedMutex.Unlock()
	fake.IsUserConnectedStub = stub
}

func (fake *FakeController) IsUserConnectedArgsForCall(i int) string {
	fake.isUserConnectedMutex.RLock()
	defer fake.isUserConnectedMutex.RUnlock()
	argsForCall := fake.isUserConnectedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) IsUserConnectedReturns(result1 bool) {
	fake.isUserConnectedMutex.Lock()
	defer fake.isUserConnectedMutex.Unlock()
	fake.IsUserConnectedStub = nil
	fake.isUserConnectedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeController) IsUserConnectedReturnsOnCall(i int, result1 bool) {
	fake.isUserConnectedMutex.Lock()
	defer fake.isUserConnectedMutex.Unlock()
	fake.IsUserConnectedStub = nil
	if fake.isUserConnectedReturnsOnCall == nil {
		fake.isUserConnectedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isUserConnectedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeController) IsUserReady(arg1 string) bool {
	fake.isUserReadyMutex.Lock()
	ret, specificReturn := fake.isUserReadyReturnsOnCall[len(fake.isUserReadyArgsForCall)]
	fake.isUserReadyArgsForCall = append(fake.isUserReadyArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.IsUserReadyStub
	fakeReturns := fake.isUserReadyReturns
	fake.recordInvocation("IsUserReady", []interface{}{arg1})
	fake.isUserReadyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) IsUserReadyCallCount() int {
	fake.isUserReadyMutex.RLock()
	defer fake.isUserReadyMutex.RUnlock()
	return len(fake.isUserReadyArgsForCall)
}

func (fake *FakeController) IsUserReadyCalls(stub func(string) bool) {
	fake.isUserReadyMutex.Lock()
	defer fake.isUserReadyMutex.Unlock()
	fake.IsUserReadyStub = stub
}

func (fake *FakeController) IsUserReadyArgsForCall(i int) string {
	fake.isUserReadyMutex.RLock()
	defer fake.isUserReadyMutex.RUnlock()
	argsForCall := fake.isUserReadyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) IsUserReadyReturns(result1 bool) {
	fake.isUserReadyMutex.Lock()
	defer fake.isUserReadyMutex.Unlock()
	fake.IsUserReadyStub = nil
	fake.isUserReadyReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeController) IsUserReadyReturnsOnCall(i int, result1 bool) {
	fake.isUserReadyMutex.Lock()
	defer fake.isUserReadyMutex.Unlock()
	fake.IsUserReadyStub = nil
	if fake.isUserReadyReturnsOnCall == nil {
		fake.isUserReadyReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isUserReadyReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeController) IsValidPage(arg1 context.Context, arg2 ...string) bool {
	fake.isValidPageMutex.Lock()
	ret, specificReturn := fake.isValidPageReturnsOnCall[len(fake.isValidPageArgsForCall)]
	fake.isValidPageArgsForCall = append(fake.isValidPageArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2})
	stub := fake.IsValidPageStub
	fakeReturns := fake.isValidPageReturns
	fake.recordInvocation("IsValidPage", []interface{}{arg1, arg2})
	fake.isValidPageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) IsValidPageCallCount() int {
	fake.isValidPageMutex.RLock()
	defer fake.isValidPageMutex.RUnlock()
	return len(fake.isValidPageArgsForCall)
}

func (fake *FakeController) IsValidPageCalls(stub func(context.Context, ...string) bool) {
	fake.isValidPageMutex.Lock()
	defer fake.isValidPageMutex.Unlock()
	fake.IsValidPageStub = stub
}

func (fake *FakeController) IsValidPageArgsForCall(i int) (context.Context, []string) {
	fake.isValidPageMutex.RLock()
	defer fake.isValidPageMutex.RUnlock()
	argsForCall := fake.isValidPageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeController) IsValidPageReturns(result1 bool) {
	fake.isValidPageMutex.Lock()
	defer fake.isValidPageMutex.Unlock()
	fake.IsValidPageStub = nil
	fake.isValidPageReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeController) IsValidPageReturnsOnCall(i int, result1 bool) {
	fake.isValidPageMutex.Lock()
	defer fake.isValidPageMutex.Unlock()
	fake.IsValidPageStub = nil
	if fake.isValidPageReturnsOnCall == nil {
		fake.isValidPageReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isValidPageReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeController) NewUser(arg1 string, arg2 string) (*session.User, error) {
	fake.newUserMutex.Lock()
	ret, specificReturn := fake.newUserReturnsOnCall[len(fake.newUserArgsForCall)]
	fake.newUserArgsForCall = append(fake.newUserArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.NewUserStub
	fakeReturns := fake.newUserReturns
	fake.recordInvocation("NewUser", []interface{}{arg1, arg2})
	fake.newUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeController) NewUserCallCount() int {
	fake.newUserMutex.RLock()
	defer fake.newUserMutex.RUnlock()
	return len(fake.newUserArgsForCall)
}

func (fake *FakeController) NewUserCalls(stub func(string, string) (*session.User, error)) {
	fake.newUserMutex.Lock()
	defer fake.newUserMutex.Unlock()
	fake.NewUserStub = stub
}

func (fake *FakeController) NewUserArgsForCall(i int) (string, string) {
	fake.newUserMutex.RLock()
	defer fake.newUserMutex.RUnlock()
	argsForCall := fake.newUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeController) NewUserReturns(result1 *session.User, result2 error) {
	fake.newUserMutex.Lock()
	defer fake.newUserMutex.Unlock()
	fake.NewUserStub = nil
	fake.newUserReturns = struct {
		result1 *session.User
		result2 error
	}{result1, result2}
}

func (fake *FakeController) NewUserReturnsOnCall(i int, result1 *session.User, result2 error) {
	fake.newUserMutex.Lock()
	defer fake.newUserMutex.Unlock()
	fake.NewUserStub = nil
	if fake.newUserReturnsOnCall == nil {
		fake.newUserReturnsOnCall = make(map[int]struct {
			result1 *session.User
			result2 error
		})
	}
	fake.newUserReturnsOnCall[i] = struct {
		result1 *session.User
		result2 error
	}{result1, result2}
}

func (fake *FakeController) NumUsers() int {
	fake.numUsersMutex.Lock()
	ret, specificReturn := fake.numUsersReturnsOnCall[len(fake.numUsersArgsForCall)]
	fake.numUsersArgsForCall = append(fake.numUsersArgsForCall, struct {
	}{})
	stub := fake.NumUsersStub
	fakeReturns := fake.numUsersReturns
	fake.recordInvocation("NumUsers", []interface{}{})
	fake.numUsersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) NumUsersCallCount() int {
	fake.numUsersMutex.RLock()
	defer fake.numUsersMutex.RUnlock()
	return len(fake.numUsersArgsForCall)
}

func (fake *FakeController) NumUsersCalls(stub func() int) {
	fake.numUsersMutex.Lock()
	defer fake.numUsersMutex.Unlock()
	fake.NumUsersStub = stub
}

func (fake *FakeController) NumUsersReturns(result1 int) {
	fake.numUsersMutex.Lock()
	defer fake.numUsersMutex.Unlock()
	fake.NumUsersStub = nil
	fake.numUsersReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeController) NumUsersReturnsOnCall(i int, result1 int) {
	fake.numUsersMutex.Lock()
	defer fake.numUsersMutex.Unlock()
	fake.NumUsersStub = nil
	if fake.numUsersReturnsOnCall == nil {
		fake.numUsersReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.numUsersReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeController) Receive(arg1 context.Context, arg2 *types.Message) error {
	fake.receiveMutex.Lock()
	ret, specificReturn := fake.receiveReturnsOnCall[len(fake.receiveArgsForCall)]
	fake.receiveArgsForCall = append(fake.receiveArgsForCall, struct {
		arg1 context.Context
		arg2 *types.Message
	}{arg1, arg2})
	stub := fake.ReceiveStub
	fakeReturns := fake.receiveReturns
	fake.recordInvocation("Receive", []interface{}{arg1, arg2})
	fake.receiveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) ReceiveCallCount() int {
	fake.receiveMutex.RLock()
	defer fake.receiveMutex.RUnlock()
	return len(fake.receiveArgsForCall)
}

func (fake *FakeController) ReceiveCalls(stub func(context.Context, *types.Message) error) {
	fake.receiveMutex.Lock()
	defer fake.receiveMutex.Unlock()
	fake.ReceiveStub = stub
}

func (fake *FakeController) ReceiveArgsForCall(i int) (context.Context, *types.Message) {
	fake.receiveMutex.RLock()
	defer fake.receiveMutex.RUnlock()
	argsForCall := fake.receiveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeController) ReceiveReturns(result1 error) {
	fake.receiveMutex.Lock()
	defer fake.receiveMutex.Unlock()
	fake.ReceiveStub = nil
	fake.receiveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) ReceiveReturnsOnCall(i int, result1 error) {
	fake.receiveMutex.Lock()
	defer fake.receiveMutex.Unlock()
	fake.ReceiveStub = nil
	if fake.receiveReturnsOnCall == nil {
		fake.receiveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.receiveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SyncPages(arg1 context.Context) error {
	fake.syncPagesMutex.Lock()
	ret, specificReturn := fake.syncPagesReturnsOnCall[len(fake.syncPagesArgsForCall)]
	fake.syncPagesArgsForCall = append(fake.syncPagesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.SyncPagesStub
	fakeReturns := fake.syncPagesReturns
	fake.recordInvocation("SyncPages", []interface{}{arg1})
	fake.syncPagesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) SyncPagesCallCount() int {
	fake.syncPagesMutex.RLock()
	defer fake.syncPagesMutex.RUnlock()
	return len(fake.syncPagesArgsForCall)
}

func (fake *FakeController) SyncPagesCalls(stub func(context.Context) error) {
	fake.syncPagesMutex.Lock()
	defer fake.syncPagesMutex.Unlock()
	fake.SyncPagesStub = stub
}

func (fake *FakeController) SyncPagesArgsForCall(i int) context.Context {
	fake.syncPagesMutex.RLock()
	defer fake.syncPagesMutex.RUnlock()
	argsForCall := fake.syncPagesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) SyncPagesReturns(result1 error) {
	fake.syncPagesMutex.Lock()
	defer fake.syncPagesMutex.Unlock()
	fake.SyncPagesStub = nil
	fake.syncPagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SyncPagesReturnsOnCall(i int, result1 error) {
	fake.syncPagesMutex.Lock()
	defer fake.syncPagesMutex.Unlock()
	fake.SyncPagesStub = nil
	if fake.syncPagesReturnsOnCall == nil {
		fake.syncPagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.syncPagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) UpdatePages(arg1 context.Context, arg2 []string, arg3 map[string]*session.PageMeta, arg4 bool) error {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.updatePagesMutex.Lock()
	ret, specificReturn := fake.updatePagesReturnsOnCall[len(fake.updatePagesArgsForCall)]
	fake.updatePagesArgsForCall = append(fake.updatePagesArgsForCall, struct {
		arg1 context.Context
		arg2 []string
		arg3 map[string]*session.PageMeta
		arg4 bool
	}{arg1, arg2Copy, arg3, arg4})
	stub := fake.UpdatePagesStub
	fakeReturns := fake.updatePagesReturns
	fake.recordInvocation("UpdatePages", []interface{}{arg1, arg2Copy, arg3, arg4})
	fake.updatePagesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) UpdatePagesCallCount() int {
	fake.updatePagesMutex.RLock()
	defer fake.updatePagesMutex.RUnlock()
	return len(fake.updatePagesArgsForCall)
}

func (fake *FakeController) UpdatePagesCalls(stub func(context.Context, []string, map[string]*session.PageMeta, bool) error) {
	fake.updatePagesMutex.Lock()
	defer fake.updatePagesMutex.Unlock()
	fake.UpdatePagesStub = stub
}

func (fake *FakeController) UpdatePagesArgsForCall(i int) (context.Context, []string, map[string]*session.PageMeta, bool) {
	fake.updatePagesMutex.RLock()
	defer fake.updatePagesMutex.RUnlock()
	argsForCall := fake.updatePagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeController) UpdatePagesReturns(result1 error) {
	fake.updatePagesMutex.Lock()
	defer fake.updatePagesMutex.Unlock()
	fake.UpdatePagesStub = nil
	fake.updatePagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) UpdatePagesReturnsOnCall(i int, result1 error) {
	fake.updatePagesMutex.Lock()
	defer fake.updatePagesMutex.Unlock()
	fake.UpdatePagesStub = nil
	if fake.updatePagesReturnsOnCall == nil {
		fake.updatePagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updatePagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) UserConnect(arg1 *session.User) {
	fake.userConnectMutex.Lock()
	fake.userConnectArgsForCall = append(fake.userConnectArgsForCall, struct {
		arg1 *session.User
	}{arg1})
	stub := fake.UserConnectStub
	fake.recordInvocation("UserConnect", []interface{}{arg1})
	fake.userConnectMutex.Unlock()
	if stub != nil {
		fake.UserConnectStub(arg1)
	}
}

func (fake *FakeController) UserConnectCallCount() int {
	fake.userConnectMutex.RLock()
	defer fake.userConnectMutex.RUnlock()
	return len(fake.userConnectArgsForCall)
}

func (fake *FakeController) UserConnectCalls(stub func(*session.User)) {
	fake.userConnectMutex.Lock()
	defer fake.userConnectMutex.Unlock()
	fake.UserConnectStub = stub
}

func (fake *FakeController) UserConnectArgsForCall(i int) *session.User {
	fake.userConnectMutex.RLock()
	defer fake.userConnectMutex.RUnlock()
	argsForCall := fake.userConnectArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) UserDisconnect(arg1 context.Context, arg2 string) {
	fake.userDisconnectMutex.Lock()
	fake.userDisconnectArgsForCall = append(fake.userDisconnectArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.UserDisconnectStub
	fake.recordInvocation("UserDisconnect", []interface{}{arg1, arg2})
	fake.userDisconnectMutex.Unlock()
	if stub != nil {
		fake.UserDisconnectStub(arg1, arg2)
	}
}

func (fake *FakeController) UserDisconnectCallCount() int {
	fake.userDisconnectMutex.RLock()
	defer fake.userDisconnectMutex.RUnlock()
	return len(fake.userDisconnectArgsForCall)
}

func (fake *FakeController) UserDisconnectCalls(stub func(context.Context, string)) {
	fake.userDisconnectMutex.Lock()
	defer fake.userDisconnectMutex.Unlock()
	fake.UserDisconnectStub = stub
}

func (fake *FakeController) UserDisconnectArgsForCall(i int) (context.Context, string) {
	fake.userDisconnectMutex.RLock()
	defer fake.userDisconnectMutex.RUnlock()
	argsForCall := fake.userDisconnectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeController) UserReady(arg1 *session.User) error {
	fake.userReadyMutex.Lock()
	ret, specificReturn := fake.userReadyReturnsOnCall[len(fake.userReadyArgsForCall)]
	fake.userReadyArgsForCall = append(fake.userReadyArgsForCall, struct {
		arg1 *session.User
	}{arg1})
	stub := fake.UserReadyStub
	fakeReturns := fake.userReadyReturns
	fake.recordInvocation("UserReady", []interface{}{arg1})
	fake.userReadyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) UserReadyCallCount() int {
	fake.userReadyMutex.RLock()
	defer fake.userReadyMutex.RUnlock()
	return len(fake.userReadyArgsForCall)
}

func (fake *FakeController) UserReadyCalls(stub func(*session.User) error) {
	fake.userReadyMutex.Lock()
	defer fake.userReadyMutex.Unlock()
	fake.UserReadyStub = stub
}

func (fake *FakeController) UserReadyArgsForCall(i int) *session.User {
	fake.userReadyMutex.RLock()
	defer fake.userReadyMutex.RUnlock()
	argsForCall := fake.userReadyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) UserReadyReturns(result1 error) {
	fake.userReadyMutex.Lock()
	defer fake.userReadyMutex.Unlock()
	fake.UserReadyStub = nil
	fake.userReadyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) UserReadyReturnsOnCall(i int, result1 error) {
	fake.userReadyMutex.Lock()
	defer fake.userReadyMutex.Unlock()
	fake.UserReadyStub = nil
	if fake.userReadyReturnsOnCall == nil {
		fake.userReadyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.userReadyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addPagesMutex.RLock()
	defer fake.addPagesMutex.RUnlock()
	fake.attachmentsMutex.RLock()
	defer fake.attachmentsMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.deletePagesMutex.RLock()
	defer fake.deletePagesMutex.RUnlock()
	fake.getPagesMutex.RLock()
	defer fake.getPagesMutex.RUnlock()
	fake.getPagesSetMutex.RLock()
	defer fake.getPagesSetMutex.RUnlock()
	fake.getStrokesMutex.RLock()
	defer fake.getStrokesMutex.RUnlock()
	fake.getUserReadyMutex.RLock()
	defer fake.getUserReadyMutex.RUnlock()
	fake.getUsersMutex.RLock()
	defer fake.getUsersMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.isUserConnectedMutex.RLock()
	defer fake.isUserConnectedMutex.RUnlock()
	fake.isUserReadyMutex.RLock()
	defer fake.isUserReadyMutex.RUnlock()
	fake.isValidPageMutex.RLock()
	defer fake.isValidPageMutex.RUnlock()
	fake.newUserMutex.RLock()
	defer fake.newUserMutex.RUnlock()
	fake.numUsersMutex.RLock()
	defer fake.numUsersMutex.RUnlock()
	fake.receiveMutex.RLock()
	defer fake.receiveMutex.RUnlock()
	fake.syncPagesMutex.RLock()
	defer fake.syncPagesMutex.RUnlock()
	fake.updatePagesMutex.RLock()
	defer fake.updatePagesMutex.RUnlock()
	fake.userConnectMutex.RLock()
	defer fake.userConnectMutex.RUnlock()
	fake.userDisconnectMutex.RLock()
	defer fake.userDisconnectMutex.RUnlock()
	fake.userReadyMutex.RLock()
	defer fake.userReadyMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeController) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ session.Controller = new(FakeController)
