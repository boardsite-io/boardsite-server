// Code generated by counterfeiter. DO NOT EDIT.
package sessionfakes

import (
	"context"
	"sync"

	"github.com/gorilla/websocket"
	"github.com/heat1q/boardsite/api/types"
	"github.com/heat1q/boardsite/attachment"
	"github.com/heat1q/boardsite/session"
)

type FakeController struct {
	AddPagesStub        func(context.Context, session.PageRequest) error
	addPagesMutex       sync.RWMutex
	addPagesArgsForCall []struct {
		arg1 context.Context
		arg2 session.PageRequest
	}
	addPagesReturns struct {
		result1 error
	}
	addPagesReturnsOnCall map[int]struct {
		result1 error
	}
	AttachmentsStub        func() attachment.Handler
	attachmentsMutex       sync.RWMutex
	attachmentsArgsForCall []struct {
	}
	attachmentsReturns struct {
		result1 attachment.Handler
	}
	attachmentsReturnsOnCall map[int]struct {
		result1 attachment.Handler
	}
	BroadcasterStub        func() session.Broadcaster
	broadcasterMutex       sync.RWMutex
	broadcasterArgsForCall []struct {
	}
	broadcasterReturns struct {
		result1 session.Broadcaster
	}
	broadcasterReturnsOnCall map[int]struct {
		result1 session.Broadcaster
	}
	CloseStub        func()
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	ConfigStub        func() session.Config
	configMutex       sync.RWMutex
	configArgsForCall []struct {
	}
	configReturns struct {
		result1 session.Config
	}
	configReturnsOnCall map[int]struct {
		result1 session.Config
	}
	GetPageStub        func(context.Context, string, bool) (*session.Page, error)
	getPageMutex       sync.RWMutex
	getPageArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 bool
	}
	getPageReturns struct {
		result1 *session.Page
		result2 error
	}
	getPageReturnsOnCall map[int]struct {
		result1 *session.Page
		result2 error
	}
	GetPageRankStub        func(context.Context) ([]string, error)
	getPageRankMutex       sync.RWMutex
	getPageRankArgsForCall []struct {
		arg1 context.Context
	}
	getPageRankReturns struct {
		result1 []string
		result2 error
	}
	getPageRankReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	GetPageSyncStub        func(context.Context, []string, bool) (*session.PageSync, error)
	getPageSyncMutex       sync.RWMutex
	getPageSyncArgsForCall []struct {
		arg1 context.Context
		arg2 []string
		arg3 bool
	}
	getPageSyncReturns struct {
		result1 *session.PageSync
		result2 error
	}
	getPageSyncReturnsOnCall map[int]struct {
		result1 *session.PageSync
		result2 error
	}
	GetUsersStub        func() map[string]*session.User
	getUsersMutex       sync.RWMutex
	getUsersArgsForCall []struct {
	}
	getUsersReturns struct {
		result1 map[string]*session.User
	}
	getUsersReturnsOnCall map[int]struct {
		result1 map[string]*session.User
	}
	IDStub        func() string
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 string
	}
	iDReturnsOnCall map[int]struct {
		result1 string
	}
	IsValidPageStub        func(context.Context, ...string) bool
	isValidPageMutex       sync.RWMutex
	isValidPageArgsForCall []struct {
		arg1 context.Context
		arg2 []string
	}
	isValidPageReturns struct {
		result1 bool
	}
	isValidPageReturnsOnCall map[int]struct {
		result1 bool
	}
	KickUserStub        func(string) error
	kickUserMutex       sync.RWMutex
	kickUserArgsForCall []struct {
		arg1 string
	}
	kickUserReturns struct {
		result1 error
	}
	kickUserReturnsOnCall map[int]struct {
		result1 error
	}
	NewUserStub        func(string, string) (*session.User, error)
	newUserMutex       sync.RWMutex
	newUserArgsForCall []struct {
		arg1 string
		arg2 string
	}
	newUserReturns struct {
		result1 *session.User
		result2 error
	}
	newUserReturnsOnCall map[int]struct {
		result1 *session.User
		result2 error
	}
	NumUsersStub        func() int
	numUsersMutex       sync.RWMutex
	numUsersArgsForCall []struct {
	}
	numUsersReturns struct {
		result1 int
	}
	numUsersReturnsOnCall map[int]struct {
		result1 int
	}
	ReceiveStub        func(context.Context, *types.Message) error
	receiveMutex       sync.RWMutex
	receiveArgsForCall []struct {
		arg1 context.Context
		arg2 *types.Message
	}
	receiveReturns struct {
		result1 error
	}
	receiveReturnsOnCall map[int]struct {
		result1 error
	}
	SetConfigStub        func(session.Config) error
	setConfigMutex       sync.RWMutex
	setConfigArgsForCall []struct {
		arg1 session.Config
	}
	setConfigReturns struct {
		result1 error
	}
	setConfigReturnsOnCall map[int]struct {
		result1 error
	}
	SyncSessionStub        func(context.Context, session.PageSync) error
	syncSessionMutex       sync.RWMutex
	syncSessionArgsForCall []struct {
		arg1 context.Context
		arg2 session.PageSync
	}
	syncSessionReturns struct {
		result1 error
	}
	syncSessionReturnsOnCall map[int]struct {
		result1 error
	}
	UpdatePagesStub        func(context.Context, session.PageRequest, string) error
	updatePagesMutex       sync.RWMutex
	updatePagesArgsForCall []struct {
		arg1 context.Context
		arg2 session.PageRequest
		arg3 string
	}
	updatePagesReturns struct {
		result1 error
	}
	updatePagesReturnsOnCall map[int]struct {
		result1 error
	}
	UserConnectStub        func(string, *websocket.Conn) error
	userConnectMutex       sync.RWMutex
	userConnectArgsForCall []struct {
		arg1 string
		arg2 *websocket.Conn
	}
	userConnectReturns struct {
		result1 error
	}
	userConnectReturnsOnCall map[int]struct {
		result1 error
	}
	UserDisconnectStub        func(context.Context, string)
	userDisconnectMutex       sync.RWMutex
	userDisconnectArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeController) AddPages(arg1 context.Context, arg2 session.PageRequest) error {
	fake.addPagesMutex.Lock()
	ret, specificReturn := fake.addPagesReturnsOnCall[len(fake.addPagesArgsForCall)]
	fake.addPagesArgsForCall = append(fake.addPagesArgsForCall, struct {
		arg1 context.Context
		arg2 session.PageRequest
	}{arg1, arg2})
	stub := fake.AddPagesStub
	fakeReturns := fake.addPagesReturns
	fake.recordInvocation("AddPages", []interface{}{arg1, arg2})
	fake.addPagesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) AddPagesCallCount() int {
	fake.addPagesMutex.RLock()
	defer fake.addPagesMutex.RUnlock()
	return len(fake.addPagesArgsForCall)
}

func (fake *FakeController) AddPagesCalls(stub func(context.Context, session.PageRequest) error) {
	fake.addPagesMutex.Lock()
	defer fake.addPagesMutex.Unlock()
	fake.AddPagesStub = stub
}

func (fake *FakeController) AddPagesArgsForCall(i int) (context.Context, session.PageRequest) {
	fake.addPagesMutex.RLock()
	defer fake.addPagesMutex.RUnlock()
	argsForCall := fake.addPagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeController) AddPagesReturns(result1 error) {
	fake.addPagesMutex.Lock()
	defer fake.addPagesMutex.Unlock()
	fake.AddPagesStub = nil
	fake.addPagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) AddPagesReturnsOnCall(i int, result1 error) {
	fake.addPagesMutex.Lock()
	defer fake.addPagesMutex.Unlock()
	fake.AddPagesStub = nil
	if fake.addPagesReturnsOnCall == nil {
		fake.addPagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addPagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) Attachments() attachment.Handler {
	fake.attachmentsMutex.Lock()
	ret, specificReturn := fake.attachmentsReturnsOnCall[len(fake.attachmentsArgsForCall)]
	fake.attachmentsArgsForCall = append(fake.attachmentsArgsForCall, struct {
	}{})
	stub := fake.AttachmentsStub
	fakeReturns := fake.attachmentsReturns
	fake.recordInvocation("Attachments", []interface{}{})
	fake.attachmentsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) AttachmentsCallCount() int {
	fake.attachmentsMutex.RLock()
	defer fake.attachmentsMutex.RUnlock()
	return len(fake.attachmentsArgsForCall)
}

func (fake *FakeController) AttachmentsCalls(stub func() attachment.Handler) {
	fake.attachmentsMutex.Lock()
	defer fake.attachmentsMutex.Unlock()
	fake.AttachmentsStub = stub
}

func (fake *FakeController) AttachmentsReturns(result1 attachment.Handler) {
	fake.attachmentsMutex.Lock()
	defer fake.attachmentsMutex.Unlock()
	fake.AttachmentsStub = nil
	fake.attachmentsReturns = struct {
		result1 attachment.Handler
	}{result1}
}

func (fake *FakeController) AttachmentsReturnsOnCall(i int, result1 attachment.Handler) {
	fake.attachmentsMutex.Lock()
	defer fake.attachmentsMutex.Unlock()
	fake.AttachmentsStub = nil
	if fake.attachmentsReturnsOnCall == nil {
		fake.attachmentsReturnsOnCall = make(map[int]struct {
			result1 attachment.Handler
		})
	}
	fake.attachmentsReturnsOnCall[i] = struct {
		result1 attachment.Handler
	}{result1}
}

func (fake *FakeController) Broadcaster() session.Broadcaster {
	fake.broadcasterMutex.Lock()
	ret, specificReturn := fake.broadcasterReturnsOnCall[len(fake.broadcasterArgsForCall)]
	fake.broadcasterArgsForCall = append(fake.broadcasterArgsForCall, struct {
	}{})
	stub := fake.BroadcasterStub
	fakeReturns := fake.broadcasterReturns
	fake.recordInvocation("Broadcaster", []interface{}{})
	fake.broadcasterMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) BroadcasterCallCount() int {
	fake.broadcasterMutex.RLock()
	defer fake.broadcasterMutex.RUnlock()
	return len(fake.broadcasterArgsForCall)
}

func (fake *FakeController) BroadcasterCalls(stub func() session.Broadcaster) {
	fake.broadcasterMutex.Lock()
	defer fake.broadcasterMutex.Unlock()
	fake.BroadcasterStub = stub
}

func (fake *FakeController) BroadcasterReturns(result1 session.Broadcaster) {
	fake.broadcasterMutex.Lock()
	defer fake.broadcasterMutex.Unlock()
	fake.BroadcasterStub = nil
	fake.broadcasterReturns = struct {
		result1 session.Broadcaster
	}{result1}
}

func (fake *FakeController) BroadcasterReturnsOnCall(i int, result1 session.Broadcaster) {
	fake.broadcasterMutex.Lock()
	defer fake.broadcasterMutex.Unlock()
	fake.BroadcasterStub = nil
	if fake.broadcasterReturnsOnCall == nil {
		fake.broadcasterReturnsOnCall = make(map[int]struct {
			result1 session.Broadcaster
		})
	}
	fake.broadcasterReturnsOnCall[i] = struct {
		result1 session.Broadcaster
	}{result1}
}

func (fake *FakeController) Close() {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		fake.CloseStub()
	}
}

func (fake *FakeController) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeController) CloseCalls(stub func()) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeController) Config() session.Config {
	fake.configMutex.Lock()
	ret, specificReturn := fake.configReturnsOnCall[len(fake.configArgsForCall)]
	fake.configArgsForCall = append(fake.configArgsForCall, struct {
	}{})
	stub := fake.ConfigStub
	fakeReturns := fake.configReturns
	fake.recordInvocation("Config", []interface{}{})
	fake.configMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) ConfigCallCount() int {
	fake.configMutex.RLock()
	defer fake.configMutex.RUnlock()
	return len(fake.configArgsForCall)
}

func (fake *FakeController) ConfigCalls(stub func() session.Config) {
	fake.configMutex.Lock()
	defer fake.configMutex.Unlock()
	fake.ConfigStub = stub
}

func (fake *FakeController) ConfigReturns(result1 session.Config) {
	fake.configMutex.Lock()
	defer fake.configMutex.Unlock()
	fake.ConfigStub = nil
	fake.configReturns = struct {
		result1 session.Config
	}{result1}
}

func (fake *FakeController) ConfigReturnsOnCall(i int, result1 session.Config) {
	fake.configMutex.Lock()
	defer fake.configMutex.Unlock()
	fake.ConfigStub = nil
	if fake.configReturnsOnCall == nil {
		fake.configReturnsOnCall = make(map[int]struct {
			result1 session.Config
		})
	}
	fake.configReturnsOnCall[i] = struct {
		result1 session.Config
	}{result1}
}

func (fake *FakeController) GetPage(arg1 context.Context, arg2 string, arg3 bool) (*session.Page, error) {
	fake.getPageMutex.Lock()
	ret, specificReturn := fake.getPageReturnsOnCall[len(fake.getPageArgsForCall)]
	fake.getPageArgsForCall = append(fake.getPageArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.GetPageStub
	fakeReturns := fake.getPageReturns
	fake.recordInvocation("GetPage", []interface{}{arg1, arg2, arg3})
	fake.getPageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeController) GetPageCallCount() int {
	fake.getPageMutex.RLock()
	defer fake.getPageMutex.RUnlock()
	return len(fake.getPageArgsForCall)
}

func (fake *FakeController) GetPageCalls(stub func(context.Context, string, bool) (*session.Page, error)) {
	fake.getPageMutex.Lock()
	defer fake.getPageMutex.Unlock()
	fake.GetPageStub = stub
}

func (fake *FakeController) GetPageArgsForCall(i int) (context.Context, string, bool) {
	fake.getPageMutex.RLock()
	defer fake.getPageMutex.RUnlock()
	argsForCall := fake.getPageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeController) GetPageReturns(result1 *session.Page, result2 error) {
	fake.getPageMutex.Lock()
	defer fake.getPageMutex.Unlock()
	fake.GetPageStub = nil
	fake.getPageReturns = struct {
		result1 *session.Page
		result2 error
	}{result1, result2}
}

func (fake *FakeController) GetPageReturnsOnCall(i int, result1 *session.Page, result2 error) {
	fake.getPageMutex.Lock()
	defer fake.getPageMutex.Unlock()
	fake.GetPageStub = nil
	if fake.getPageReturnsOnCall == nil {
		fake.getPageReturnsOnCall = make(map[int]struct {
			result1 *session.Page
			result2 error
		})
	}
	fake.getPageReturnsOnCall[i] = struct {
		result1 *session.Page
		result2 error
	}{result1, result2}
}

func (fake *FakeController) GetPageRank(arg1 context.Context) ([]string, error) {
	fake.getPageRankMutex.Lock()
	ret, specificReturn := fake.getPageRankReturnsOnCall[len(fake.getPageRankArgsForCall)]
	fake.getPageRankArgsForCall = append(fake.getPageRankArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetPageRankStub
	fakeReturns := fake.getPageRankReturns
	fake.recordInvocation("GetPageRank", []interface{}{arg1})
	fake.getPageRankMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeController) GetPageRankCallCount() int {
	fake.getPageRankMutex.RLock()
	defer fake.getPageRankMutex.RUnlock()
	return len(fake.getPageRankArgsForCall)
}

func (fake *FakeController) GetPageRankCalls(stub func(context.Context) ([]string, error)) {
	fake.getPageRankMutex.Lock()
	defer fake.getPageRankMutex.Unlock()
	fake.GetPageRankStub = stub
}

func (fake *FakeController) GetPageRankArgsForCall(i int) context.Context {
	fake.getPageRankMutex.RLock()
	defer fake.getPageRankMutex.RUnlock()
	argsForCall := fake.getPageRankArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) GetPageRankReturns(result1 []string, result2 error) {
	fake.getPageRankMutex.Lock()
	defer fake.getPageRankMutex.Unlock()
	fake.GetPageRankStub = nil
	fake.getPageRankReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeController) GetPageRankReturnsOnCall(i int, result1 []string, result2 error) {
	fake.getPageRankMutex.Lock()
	defer fake.getPageRankMutex.Unlock()
	fake.GetPageRankStub = nil
	if fake.getPageRankReturnsOnCall == nil {
		fake.getPageRankReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getPageRankReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeController) GetPageSync(arg1 context.Context, arg2 []string, arg3 bool) (*session.PageSync, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.getPageSyncMutex.Lock()
	ret, specificReturn := fake.getPageSyncReturnsOnCall[len(fake.getPageSyncArgsForCall)]
	fake.getPageSyncArgsForCall = append(fake.getPageSyncArgsForCall, struct {
		arg1 context.Context
		arg2 []string
		arg3 bool
	}{arg1, arg2Copy, arg3})
	stub := fake.GetPageSyncStub
	fakeReturns := fake.getPageSyncReturns
	fake.recordInvocation("GetPageSync", []interface{}{arg1, arg2Copy, arg3})
	fake.getPageSyncMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeController) GetPageSyncCallCount() int {
	fake.getPageSyncMutex.RLock()
	defer fake.getPageSyncMutex.RUnlock()
	return len(fake.getPageSyncArgsForCall)
}

func (fake *FakeController) GetPageSyncCalls(stub func(context.Context, []string, bool) (*session.PageSync, error)) {
	fake.getPageSyncMutex.Lock()
	defer fake.getPageSyncMutex.Unlock()
	fake.GetPageSyncStub = stub
}

func (fake *FakeController) GetPageSyncArgsForCall(i int) (context.Context, []string, bool) {
	fake.getPageSyncMutex.RLock()
	defer fake.getPageSyncMutex.RUnlock()
	argsForCall := fake.getPageSyncArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeController) GetPageSyncReturns(result1 *session.PageSync, result2 error) {
	fake.getPageSyncMutex.Lock()
	defer fake.getPageSyncMutex.Unlock()
	fake.GetPageSyncStub = nil
	fake.getPageSyncReturns = struct {
		result1 *session.PageSync
		result2 error
	}{result1, result2}
}

func (fake *FakeController) GetPageSyncReturnsOnCall(i int, result1 *session.PageSync, result2 error) {
	fake.getPageSyncMutex.Lock()
	defer fake.getPageSyncMutex.Unlock()
	fake.GetPageSyncStub = nil
	if fake.getPageSyncReturnsOnCall == nil {
		fake.getPageSyncReturnsOnCall = make(map[int]struct {
			result1 *session.PageSync
			result2 error
		})
	}
	fake.getPageSyncReturnsOnCall[i] = struct {
		result1 *session.PageSync
		result2 error
	}{result1, result2}
}

func (fake *FakeController) GetUsers() map[string]*session.User {
	fake.getUsersMutex.Lock()
	ret, specificReturn := fake.getUsersReturnsOnCall[len(fake.getUsersArgsForCall)]
	fake.getUsersArgsForCall = append(fake.getUsersArgsForCall, struct {
	}{})
	stub := fake.GetUsersStub
	fakeReturns := fake.getUsersReturns
	fake.recordInvocation("GetUsers", []interface{}{})
	fake.getUsersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) GetUsersCallCount() int {
	fake.getUsersMutex.RLock()
	defer fake.getUsersMutex.RUnlock()
	return len(fake.getUsersArgsForCall)
}

func (fake *FakeController) GetUsersCalls(stub func() map[string]*session.User) {
	fake.getUsersMutex.Lock()
	defer fake.getUsersMutex.Unlock()
	fake.GetUsersStub = stub
}

func (fake *FakeController) GetUsersReturns(result1 map[string]*session.User) {
	fake.getUsersMutex.Lock()
	defer fake.getUsersMutex.Unlock()
	fake.GetUsersStub = nil
	fake.getUsersReturns = struct {
		result1 map[string]*session.User
	}{result1}
}

func (fake *FakeController) GetUsersReturnsOnCall(i int, result1 map[string]*session.User) {
	fake.getUsersMutex.Lock()
	defer fake.getUsersMutex.Unlock()
	fake.GetUsersStub = nil
	if fake.getUsersReturnsOnCall == nil {
		fake.getUsersReturnsOnCall = make(map[int]struct {
			result1 map[string]*session.User
		})
	}
	fake.getUsersReturnsOnCall[i] = struct {
		result1 map[string]*session.User
	}{result1}
}

func (fake *FakeController) ID() string {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	stub := fake.IDStub
	fakeReturns := fake.iDReturns
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeController) IDCalls(stub func() string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakeController) IDReturns(result1 string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeController) IDReturnsOnCall(i int, result1 string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeController) IsValidPage(arg1 context.Context, arg2 ...string) bool {
	fake.isValidPageMutex.Lock()
	ret, specificReturn := fake.isValidPageReturnsOnCall[len(fake.isValidPageArgsForCall)]
	fake.isValidPageArgsForCall = append(fake.isValidPageArgsForCall, struct {
		arg1 context.Context
		arg2 []string
	}{arg1, arg2})
	stub := fake.IsValidPageStub
	fakeReturns := fake.isValidPageReturns
	fake.recordInvocation("IsValidPage", []interface{}{arg1, arg2})
	fake.isValidPageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) IsValidPageCallCount() int {
	fake.isValidPageMutex.RLock()
	defer fake.isValidPageMutex.RUnlock()
	return len(fake.isValidPageArgsForCall)
}

func (fake *FakeController) IsValidPageCalls(stub func(context.Context, ...string) bool) {
	fake.isValidPageMutex.Lock()
	defer fake.isValidPageMutex.Unlock()
	fake.IsValidPageStub = stub
}

func (fake *FakeController) IsValidPageArgsForCall(i int) (context.Context, []string) {
	fake.isValidPageMutex.RLock()
	defer fake.isValidPageMutex.RUnlock()
	argsForCall := fake.isValidPageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeController) IsValidPageReturns(result1 bool) {
	fake.isValidPageMutex.Lock()
	defer fake.isValidPageMutex.Unlock()
	fake.IsValidPageStub = nil
	fake.isValidPageReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeController) IsValidPageReturnsOnCall(i int, result1 bool) {
	fake.isValidPageMutex.Lock()
	defer fake.isValidPageMutex.Unlock()
	fake.IsValidPageStub = nil
	if fake.isValidPageReturnsOnCall == nil {
		fake.isValidPageReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isValidPageReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeController) KickUser(arg1 string) error {
	fake.kickUserMutex.Lock()
	ret, specificReturn := fake.kickUserReturnsOnCall[len(fake.kickUserArgsForCall)]
	fake.kickUserArgsForCall = append(fake.kickUserArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.KickUserStub
	fakeReturns := fake.kickUserReturns
	fake.recordInvocation("KickUser", []interface{}{arg1})
	fake.kickUserMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) KickUserCallCount() int {
	fake.kickUserMutex.RLock()
	defer fake.kickUserMutex.RUnlock()
	return len(fake.kickUserArgsForCall)
}

func (fake *FakeController) KickUserCalls(stub func(string) error) {
	fake.kickUserMutex.Lock()
	defer fake.kickUserMutex.Unlock()
	fake.KickUserStub = stub
}

func (fake *FakeController) KickUserArgsForCall(i int) string {
	fake.kickUserMutex.RLock()
	defer fake.kickUserMutex.RUnlock()
	argsForCall := fake.kickUserArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) KickUserReturns(result1 error) {
	fake.kickUserMutex.Lock()
	defer fake.kickUserMutex.Unlock()
	fake.KickUserStub = nil
	fake.kickUserReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) KickUserReturnsOnCall(i int, result1 error) {
	fake.kickUserMutex.Lock()
	defer fake.kickUserMutex.Unlock()
	fake.KickUserStub = nil
	if fake.kickUserReturnsOnCall == nil {
		fake.kickUserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.kickUserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) NewUser(arg1 string, arg2 string) (*session.User, error) {
	fake.newUserMutex.Lock()
	ret, specificReturn := fake.newUserReturnsOnCall[len(fake.newUserArgsForCall)]
	fake.newUserArgsForCall = append(fake.newUserArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.NewUserStub
	fakeReturns := fake.newUserReturns
	fake.recordInvocation("NewUser", []interface{}{arg1, arg2})
	fake.newUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeController) NewUserCallCount() int {
	fake.newUserMutex.RLock()
	defer fake.newUserMutex.RUnlock()
	return len(fake.newUserArgsForCall)
}

func (fake *FakeController) NewUserCalls(stub func(string, string) (*session.User, error)) {
	fake.newUserMutex.Lock()
	defer fake.newUserMutex.Unlock()
	fake.NewUserStub = stub
}

func (fake *FakeController) NewUserArgsForCall(i int) (string, string) {
	fake.newUserMutex.RLock()
	defer fake.newUserMutex.RUnlock()
	argsForCall := fake.newUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeController) NewUserReturns(result1 *session.User, result2 error) {
	fake.newUserMutex.Lock()
	defer fake.newUserMutex.Unlock()
	fake.NewUserStub = nil
	fake.newUserReturns = struct {
		result1 *session.User
		result2 error
	}{result1, result2}
}

func (fake *FakeController) NewUserReturnsOnCall(i int, result1 *session.User, result2 error) {
	fake.newUserMutex.Lock()
	defer fake.newUserMutex.Unlock()
	fake.NewUserStub = nil
	if fake.newUserReturnsOnCall == nil {
		fake.newUserReturnsOnCall = make(map[int]struct {
			result1 *session.User
			result2 error
		})
	}
	fake.newUserReturnsOnCall[i] = struct {
		result1 *session.User
		result2 error
	}{result1, result2}
}

func (fake *FakeController) NumUsers() int {
	fake.numUsersMutex.Lock()
	ret, specificReturn := fake.numUsersReturnsOnCall[len(fake.numUsersArgsForCall)]
	fake.numUsersArgsForCall = append(fake.numUsersArgsForCall, struct {
	}{})
	stub := fake.NumUsersStub
	fakeReturns := fake.numUsersReturns
	fake.recordInvocation("NumUsers", []interface{}{})
	fake.numUsersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) NumUsersCallCount() int {
	fake.numUsersMutex.RLock()
	defer fake.numUsersMutex.RUnlock()
	return len(fake.numUsersArgsForCall)
}

func (fake *FakeController) NumUsersCalls(stub func() int) {
	fake.numUsersMutex.Lock()
	defer fake.numUsersMutex.Unlock()
	fake.NumUsersStub = stub
}

func (fake *FakeController) NumUsersReturns(result1 int) {
	fake.numUsersMutex.Lock()
	defer fake.numUsersMutex.Unlock()
	fake.NumUsersStub = nil
	fake.numUsersReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeController) NumUsersReturnsOnCall(i int, result1 int) {
	fake.numUsersMutex.Lock()
	defer fake.numUsersMutex.Unlock()
	fake.NumUsersStub = nil
	if fake.numUsersReturnsOnCall == nil {
		fake.numUsersReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.numUsersReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeController) Receive(arg1 context.Context, arg2 *types.Message) error {
	fake.receiveMutex.Lock()
	ret, specificReturn := fake.receiveReturnsOnCall[len(fake.receiveArgsForCall)]
	fake.receiveArgsForCall = append(fake.receiveArgsForCall, struct {
		arg1 context.Context
		arg2 *types.Message
	}{arg1, arg2})
	stub := fake.ReceiveStub
	fakeReturns := fake.receiveReturns
	fake.recordInvocation("Receive", []interface{}{arg1, arg2})
	fake.receiveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) ReceiveCallCount() int {
	fake.receiveMutex.RLock()
	defer fake.receiveMutex.RUnlock()
	return len(fake.receiveArgsForCall)
}

func (fake *FakeController) ReceiveCalls(stub func(context.Context, *types.Message) error) {
	fake.receiveMutex.Lock()
	defer fake.receiveMutex.Unlock()
	fake.ReceiveStub = stub
}

func (fake *FakeController) ReceiveArgsForCall(i int) (context.Context, *types.Message) {
	fake.receiveMutex.RLock()
	defer fake.receiveMutex.RUnlock()
	argsForCall := fake.receiveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeController) ReceiveReturns(result1 error) {
	fake.receiveMutex.Lock()
	defer fake.receiveMutex.Unlock()
	fake.ReceiveStub = nil
	fake.receiveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) ReceiveReturnsOnCall(i int, result1 error) {
	fake.receiveMutex.Lock()
	defer fake.receiveMutex.Unlock()
	fake.ReceiveStub = nil
	if fake.receiveReturnsOnCall == nil {
		fake.receiveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.receiveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SetConfig(arg1 session.Config) error {
	fake.setConfigMutex.Lock()
	ret, specificReturn := fake.setConfigReturnsOnCall[len(fake.setConfigArgsForCall)]
	fake.setConfigArgsForCall = append(fake.setConfigArgsForCall, struct {
		arg1 session.Config
	}{arg1})
	stub := fake.SetConfigStub
	fakeReturns := fake.setConfigReturns
	fake.recordInvocation("SetConfig", []interface{}{arg1})
	fake.setConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) SetConfigCallCount() int {
	fake.setConfigMutex.RLock()
	defer fake.setConfigMutex.RUnlock()
	return len(fake.setConfigArgsForCall)
}

func (fake *FakeController) SetConfigCalls(stub func(session.Config) error) {
	fake.setConfigMutex.Lock()
	defer fake.setConfigMutex.Unlock()
	fake.SetConfigStub = stub
}

func (fake *FakeController) SetConfigArgsForCall(i int) session.Config {
	fake.setConfigMutex.RLock()
	defer fake.setConfigMutex.RUnlock()
	argsForCall := fake.setConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeController) SetConfigReturns(result1 error) {
	fake.setConfigMutex.Lock()
	defer fake.setConfigMutex.Unlock()
	fake.SetConfigStub = nil
	fake.setConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SetConfigReturnsOnCall(i int, result1 error) {
	fake.setConfigMutex.Lock()
	defer fake.setConfigMutex.Unlock()
	fake.SetConfigStub = nil
	if fake.setConfigReturnsOnCall == nil {
		fake.setConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SyncSession(arg1 context.Context, arg2 session.PageSync) error {
	fake.syncSessionMutex.Lock()
	ret, specificReturn := fake.syncSessionReturnsOnCall[len(fake.syncSessionArgsForCall)]
	fake.syncSessionArgsForCall = append(fake.syncSessionArgsForCall, struct {
		arg1 context.Context
		arg2 session.PageSync
	}{arg1, arg2})
	stub := fake.SyncSessionStub
	fakeReturns := fake.syncSessionReturns
	fake.recordInvocation("SyncSession", []interface{}{arg1, arg2})
	fake.syncSessionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) SyncSessionCallCount() int {
	fake.syncSessionMutex.RLock()
	defer fake.syncSessionMutex.RUnlock()
	return len(fake.syncSessionArgsForCall)
}

func (fake *FakeController) SyncSessionCalls(stub func(context.Context, session.PageSync) error) {
	fake.syncSessionMutex.Lock()
	defer fake.syncSessionMutex.Unlock()
	fake.SyncSessionStub = stub
}

func (fake *FakeController) SyncSessionArgsForCall(i int) (context.Context, session.PageSync) {
	fake.syncSessionMutex.RLock()
	defer fake.syncSessionMutex.RUnlock()
	argsForCall := fake.syncSessionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeController) SyncSessionReturns(result1 error) {
	fake.syncSessionMutex.Lock()
	defer fake.syncSessionMutex.Unlock()
	fake.SyncSessionStub = nil
	fake.syncSessionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) SyncSessionReturnsOnCall(i int, result1 error) {
	fake.syncSessionMutex.Lock()
	defer fake.syncSessionMutex.Unlock()
	fake.SyncSessionStub = nil
	if fake.syncSessionReturnsOnCall == nil {
		fake.syncSessionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.syncSessionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) UpdatePages(arg1 context.Context, arg2 session.PageRequest, arg3 string) error {
	fake.updatePagesMutex.Lock()
	ret, specificReturn := fake.updatePagesReturnsOnCall[len(fake.updatePagesArgsForCall)]
	fake.updatePagesArgsForCall = append(fake.updatePagesArgsForCall, struct {
		arg1 context.Context
		arg2 session.PageRequest
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.UpdatePagesStub
	fakeReturns := fake.updatePagesReturns
	fake.recordInvocation("UpdatePages", []interface{}{arg1, arg2, arg3})
	fake.updatePagesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) UpdatePagesCallCount() int {
	fake.updatePagesMutex.RLock()
	defer fake.updatePagesMutex.RUnlock()
	return len(fake.updatePagesArgsForCall)
}

func (fake *FakeController) UpdatePagesCalls(stub func(context.Context, session.PageRequest, string) error) {
	fake.updatePagesMutex.Lock()
	defer fake.updatePagesMutex.Unlock()
	fake.UpdatePagesStub = stub
}

func (fake *FakeController) UpdatePagesArgsForCall(i int) (context.Context, session.PageRequest, string) {
	fake.updatePagesMutex.RLock()
	defer fake.updatePagesMutex.RUnlock()
	argsForCall := fake.updatePagesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeController) UpdatePagesReturns(result1 error) {
	fake.updatePagesMutex.Lock()
	defer fake.updatePagesMutex.Unlock()
	fake.UpdatePagesStub = nil
	fake.updatePagesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) UpdatePagesReturnsOnCall(i int, result1 error) {
	fake.updatePagesMutex.Lock()
	defer fake.updatePagesMutex.Unlock()
	fake.UpdatePagesStub = nil
	if fake.updatePagesReturnsOnCall == nil {
		fake.updatePagesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updatePagesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) UserConnect(arg1 string, arg2 *websocket.Conn) error {
	fake.userConnectMutex.Lock()
	ret, specificReturn := fake.userConnectReturnsOnCall[len(fake.userConnectArgsForCall)]
	fake.userConnectArgsForCall = append(fake.userConnectArgsForCall, struct {
		arg1 string
		arg2 *websocket.Conn
	}{arg1, arg2})
	stub := fake.UserConnectStub
	fakeReturns := fake.userConnectReturns
	fake.recordInvocation("UserConnect", []interface{}{arg1, arg2})
	fake.userConnectMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeController) UserConnectCallCount() int {
	fake.userConnectMutex.RLock()
	defer fake.userConnectMutex.RUnlock()
	return len(fake.userConnectArgsForCall)
}

func (fake *FakeController) UserConnectCalls(stub func(string, *websocket.Conn) error) {
	fake.userConnectMutex.Lock()
	defer fake.userConnectMutex.Unlock()
	fake.UserConnectStub = stub
}

func (fake *FakeController) UserConnectArgsForCall(i int) (string, *websocket.Conn) {
	fake.userConnectMutex.RLock()
	defer fake.userConnectMutex.RUnlock()
	argsForCall := fake.userConnectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeController) UserConnectReturns(result1 error) {
	fake.userConnectMutex.Lock()
	defer fake.userConnectMutex.Unlock()
	fake.UserConnectStub = nil
	fake.userConnectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) UserConnectReturnsOnCall(i int, result1 error) {
	fake.userConnectMutex.Lock()
	defer fake.userConnectMutex.Unlock()
	fake.UserConnectStub = nil
	if fake.userConnectReturnsOnCall == nil {
		fake.userConnectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.userConnectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeController) UserDisconnect(arg1 context.Context, arg2 string) {
	fake.userDisconnectMutex.Lock()
	fake.userDisconnectArgsForCall = append(fake.userDisconnectArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.UserDisconnectStub
	fake.recordInvocation("UserDisconnect", []interface{}{arg1, arg2})
	fake.userDisconnectMutex.Unlock()
	if stub != nil {
		fake.UserDisconnectStub(arg1, arg2)
	}
}

func (fake *FakeController) UserDisconnectCallCount() int {
	fake.userDisconnectMutex.RLock()
	defer fake.userDisconnectMutex.RUnlock()
	return len(fake.userDisconnectArgsForCall)
}

func (fake *FakeController) UserDisconnectCalls(stub func(context.Context, string)) {
	fake.userDisconnectMutex.Lock()
	defer fake.userDisconnectMutex.Unlock()
	fake.UserDisconnectStub = stub
}

func (fake *FakeController) UserDisconnectArgsForCall(i int) (context.Context, string) {
	fake.userDisconnectMutex.RLock()
	defer fake.userDisconnectMutex.RUnlock()
	argsForCall := fake.userDisconnectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeController) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addPagesMutex.RLock()
	defer fake.addPagesMutex.RUnlock()
	fake.attachmentsMutex.RLock()
	defer fake.attachmentsMutex.RUnlock()
	fake.broadcasterMutex.RLock()
	defer fake.broadcasterMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.configMutex.RLock()
	defer fake.configMutex.RUnlock()
	fake.getPageMutex.RLock()
	defer fake.getPageMutex.RUnlock()
	fake.getPageRankMutex.RLock()
	defer fake.getPageRankMutex.RUnlock()
	fake.getPageSyncMutex.RLock()
	defer fake.getPageSyncMutex.RUnlock()
	fake.getUsersMutex.RLock()
	defer fake.getUsersMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.isValidPageMutex.RLock()
	defer fake.isValidPageMutex.RUnlock()
	fake.kickUserMutex.RLock()
	defer fake.kickUserMutex.RUnlock()
	fake.newUserMutex.RLock()
	defer fake.newUserMutex.RUnlock()
	fake.numUsersMutex.RLock()
	defer fake.numUsersMutex.RUnlock()
	fake.receiveMutex.RLock()
	defer fake.receiveMutex.RUnlock()
	fake.setConfigMutex.RLock()
	defer fake.setConfigMutex.RUnlock()
	fake.syncSessionMutex.RLock()
	defer fake.syncSessionMutex.RUnlock()
	fake.updatePagesMutex.RLock()
	defer fake.updatePagesMutex.RUnlock()
	fake.userConnectMutex.RLock()
	defer fake.userConnectMutex.RUnlock()
	fake.userDisconnectMutex.RLock()
	defer fake.userDisconnectMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeController) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ session.Controller = new(FakeController)
